#!/bin/zsh

# shellcheck shell=bash

tm() # Tmux session based on directory name
{
  local name="$(basename "$PWD")"
  if [ -n "$TMUX" ]; then
    tmux switch-client -t "$name" 2>/dev/null || tmux new-session -ds "$name"
  else
    tmux attach -t "$name" 2>/dev/null || tmux new -s "$name"
  fi
}

ahelp() # List custom aliases and execute selected one
{
  local selection alias_name alias_cmd
  # Show all aliases from the file in fzf
  selection=$(rg -N '^alias [^_]' "$DOTFILES/zsh/.aliases" | sed 's/^alias //' | fzf) || return

  # If nothing selected, exit
  [[ -z "$selection" ]] && return

  # Extract alias name and command
  alias_name="${selection%%=*}"               # before =
  alias_cmd="${selection#*=}"                 # after =
  alias_cmd="${alias_cmd%\"}"                 # remove trailing quote if any
  alias_cmd="${alias_cmd#\"}"                 # remove leading quote if any

  # Execute the command
  eval "$alias_cmd"
}

fhelp() # List all custom functions
{
    rg -N '^[a-zA-Z]' \
        "$DOTFILES"/zsh/.functions \
        "$DOTFILES"/git/.git-functions \
        "$DOTFILES"/zsh/.dockerfunc \
        | sed -E 's/\(\)\s*#\s*/ /' \
        | sed 's/^[^:]*://' \
        | sort \
        | fzf --preview="$(_fzf_preview_skip_first_field)" \
            --with-nth=1 \
            --delimiter=' '
}


_has() # Check whether executable exists
{
    command -v "$1" >/dev/null 2>&1
}

_fzf-down() 
{
    fzf --height 50% "$@"
}

_fzf_preview_skip_n_fields() # Generate awk command to skip first n fields from fzf preview
{
    local n="${1:-1}"
    local delim="${2:- }"

    if [[ "$delim" == $'\t' ]]; then
        print -r -- "echo {} | awk -F'\t' -v n=\"$n\" 'BEGIN{OFS=\"\t\"} {for(i=1;i<=n;i++) \$i=\"\"; sub(/^[[:space:]]+/, \"\"); print}'"
    else
        print -r -- "echo {} | awk -F' ' -v n=\"$n\" '{for(i=1;i<=n;i++) \$i=\"\"; sub(/^ +/, \"\"); print}'"
    fi
}

_fzf_preview_skip_first_field() # Generate awk command to skip first field from fzf preview
{
    local delim="${1:- }"

    _fzf_preview_skip_n_fields 1 "$delim"
}

latest() # Show latest created file
{
    ls -lt -d "$1"/*/ | head -n1 | awk '{print $NF}'
}

backup() # Backup files and folders
{
	FILE=$1
	BACKUP_NAME="$FILE-[\"$(date + '%Y-%m-%d-%H:%M:%S')\"]"
	DIRECTORY="$HOME/backups"

	# Check if backup folder exists
	if [ ! -d "$DIRECTORY" ]; then
		mkdir "$DIRECTORY"
	fi

  	# check if passed argument is file or directory
	if [[ -d $FILE ]]; then
		echo "Creating backup of the directory: $FILE"
    	tar -czf "$DIRECTORY/$BACKUP_NAME.tar.gz" --exclude={"$FILE"/.venv,"$FILE"/node_modules} "$FILE"
	elif [[ -f $FILE ]]; then
		echo "Creating backup of the file: $FILE"
		cp -a "$FILE" "$DIRECTORY"
	else
		echo "$FILE is not valid format"
	fi
}

convert_datetime() # Convert DD/MM/YY date format to YYYY-MM-DD
{
    sed 's_\([0-9]\{1,2\}\)/\([0-9]\{1,2\}\)/\([0-9]\{2\}\)_20\3-\2-\1_g'
}

# Override default man page
function man() # Shows pretty man page
{
  env \
    LESS_TERMCAP_mb="$(printf '\e[1;31m')" \
    LESS_TERMCAP_md="$(printf '\e[1;31m')" \
    LESS_TERMCAP_me="$(printf '\e[0m')" \
    LESS_TERMCAP_se="$(printf '\e[0m')" \
    LESS_TERMCAP_so="$(printf '\e[1;44;33m')" \
    LESS_TERMCAP_ue="$(printf '\e[0m')" \
    LESS_TERMCAP_us="$(printf '\e[1;32m')" \
      man "$@"
}

targz() # Targz a file
{
	local tmpFile="${@%/}.tar";
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
	);

	local cmd="";
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli";
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz";
		else
			cmd="gzip";
		fi;
	fi;

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
	"${cmd}" -v "${tmpFile}" || return 1;
	[ -f "${tmpFile}" ] && rm "${tmpFile}";

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
	);

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

short() # Shorten url
{
   url=$1
   curl -s http://tinyurl.com/api-create.php\?url\="$url" | xargs
}



# USAGE: gifify video.mov [--width=800] [--height=600] [--fps=10] [--delay=10]
gifify() {
    local input="$1"
    local width=800 height=600 fps=10 delay=10
    
    [[ -z "$input" ]] && {
        echo "Usage: gifify <input> [--width=N] [--height=N] [--fps=N] [--delay=N]"
        return 1
    }
    
    # Parse options
    shift
    while [[ $# -gt 0 ]]; do
        case $1 in
            --width=*) width="${1#*=}" ;;
            --height=*) height="${1#*=}" ;;
            --fps=*) fps="${1#*=}" ;;
            --delay=*) delay="${1#*=}" ;;
            *) echo "Unknown: $1"; return 1 ;;
        esac
        shift
    done
    
    local output="${input%.*}.gif"
    
    # Check dependencies
    for cmd in ffmpeg convert gifsicle; do
        command -v $cmd >/dev/null 2>&1 || {
            echo "Error: $cmd not found. Install: brew install ffmpeg imagemagick gifsicle"
            return 1
        }
    done
    
    echo "Converting $input → $output (${width}x${height}, ${fps}fps)"
    
    # Extract high-quality PNG frames with proper scaling
    ffmpeg -hide_banner -loglevel error -i "$input" -r "$fps" \
        -vf "scale=${width}:${height}:force_original_aspect_ratio=decrease:flags=lanczos" \
        -vcodec png -sws_flags lanczos+accurate_rnd+full_chroma_int \
        "frame-%05d.png"
    
    # Build convert/gifsicle options
    local convert_opts=(-limit memory 2GiB -limit map 4GiB +dither -layers Optimize)
    local gifsicle_opts=(--colors 256 --delay="$delay" --loop --optimize=3 --multifile)
    
    # Convert to optimized GIF
    convert "${convert_opts[@]}" frame-*.png GIF:- | \
        gifsicle "${gifsicle_opts[@]}" - > "$output"
    
    # Cleanup
    rm -f frame-*.png
    
    echo "✓ Created $output ($(du -h "$output" | cut -f1))"
    command -v identify >/dev/null 2>&1 && identify "$output" | head -1
}

fcd() # FZF with cd command 
{
  local DIR=$(
    fd --type d | fzf +m --select-1 --preview 'tree -C {} | head -n 50'
  )
  if [ -n "$DIR" ]; then
    cd "$DIR" || exit
  fi
}

ghexport() # Download single folder from github
{
	github_link=$1
	remove_path="/tree/master"
  	link="${github_link/$remove_path/trunk/}"
	svn export "${link}"
}

listen() # Check what is listening on specific port
{
    if [ $# -eq 0 ]; then
        sudo lsof -iTCP -sTCP:LISTEN -n -P
    elif [ $# -eq 1 ]; then
        sudo lsof -iTCP -sTCP:LISTEN -n -P | grep -i --color "$1"
    else
        echo "Usage: listen [pattern]"
    fi
}

isup() # Check if URL is up
{
	local uri=$1

	if curl -s --head  --request GET "$uri" | grep "200 OK" > /dev/null ; then
		notify-send --urgency=critical "$uri is down"
	else
		notify-send --urgency=low "$uri is up"
	fi
}


ssh-key() # generate ssh key with specific name
{
    if [ -z "$1" ]; then
        echo "Error: No name provided. Usage: ssh-key <key-name>"
        return 1
    fi

    name="$@"
    ssh-keygen -f ~/.ssh/"$name" -q -N ""
    eval "$(ssh-agent -s)"
    ssh-add ~/.ssh/"$name"

    # Copy public key to clipboard
    if command -v xclip &> /dev/null; then
        xclip -selection clipboard < ~/.ssh/"$name".pub
        echo "Public key copied to clipboard."
    else
        echo "xclip is not installed. Public key:"
        cat ~/.ssh/"$name".pub
    fi
} 

# Usage: json '{"foo":42}' or echo '{"foo":42}' | json
json() # Format json string
{
	if [ -t 0 ]; then # argument
		python3 -mjson.tool <<< "$*" | pygmentize -l javascript;
	else
		python3 -mjson.tool | pygmentize -l javascript;
	fi
}

token() # generate secret token
{
	length=${1:-16}  # Use provided length or default to 16
    python3 -c "import secrets; print(secrets.token_urlsafe(${length}))" | pbcopy
}

# Postgres
create-db() # Drop and re-create db if exists or create new one
{
    if [ "${#@}" -eq 0 ]; then
        echo "No DB name provided."
    else
        port=${2:-5432}
        dropdb -f --if-exists "$1"
        createdb -h 127.0.0.1 -p "$port" -U postgres "$1" 
        echo "Database $1 successfully re-created!"
    fi
}

delete-db() # Delete database if exiss
{
    dropdb -f --if-exists "$@"
}

makerun() # Run makefile command
{
  local makefile_path
  makefile_path=$(find . -maxdepth 2 -name "Makefile" -print -quit)

  # Verify the Makefile Exists
  if [[ -z "$makefile_path" ]]; then
    echo "Error: No 'Makefile' found in the current directory or its parent."
    return 1
  fi

  # Parse Commands into a temporary variable
  local command_list
  command_list=$(command grep -E '^[a-zA-Z0-9_-]+:.*?## .*$$' "$makefile_path" | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $1, $2}')

  # Check if any commands were found
  if [[ -z "$command_list" ]]; then
    echo "Info: No runnable commands (with '##' comments) found in '$makefile_path'."
    return 1
  fi

  local selected_command
  selected_command=$(echo "$command_list" | fzf --height 50% --ansi --nth=1 --reverse --prompt="make " --header="Select a target to run:" | awk '{print $1}')

  # Execute the Selected Command
  if [[ -n "$selected_command" ]]; then
    echo "Executing: make -f $makefile_path $selected_command"
    make -f "$makefile_path" "$selected_command"
  else
    echo "No command selected. Aborting."
  fi
}

pngtojpg() # Bulk convert png to jpg
{
	for i in *.png ; do convert "$i" "${i%.*}.jpg" ; done
}

clean_deps() # Remove node, python, php dependencies
{
    folders=("node_modules" ".venv" "vendor")
    days=${1:-90}

    for folder in "${folders[@]}"
    do
        fd -H -t d -d 4 "^${folder}$" ~/dev --changed-before "${days}days" \
            --exec echo "Removing {}" \; \
            --exec rm -rf {}
    done
}

install_latest_release() # Download and install latest release from Github
{
    repo=$1
    url=https://api.github.com/repos/$repo/releases/latest
    download_url="$(curl -s "$url" \
        | grep "browser_download_url.*deb\"" \
        | cut -d : -f 2,3 \
        | tr -d \" \
        | xargs)"
    filename=$(basename "$download_url")
    echo "Downloading file: $download_url"
    wget -q "$download_url"
    sudo dpkg -i "$filename"
    rm "$filename"
}

upgrade-deps() # Upgrade global dependencies
{
    npx npm-check --global --update-all
    pip3 install --upgrade pip
    pip3 freeze | grep -v "^\-e" | grep -v "@" | cut -d = -f 1 | xargs pip3 install -U
}

timezsh() # Time ZSH load time
{
  shell=${1-$SHELL}
  for i in $(seq 1 10); do /usr/bin/time "$shell" -i -c exit; done
}

kport() # Kill processes interactively with fzf (supports port number search)
{
    local pids signal port_info
    signal="15"
    
    # Format strings and commands
    local header_format="%-8s %-6s %-6s %-s %s\n"
    
    local ps_filter='NR>1 && $11 !~ /^(\[|\/System\/|\/usr\/libexec\/)/ && $11 != "ps"'
    # Filter: skip header, exclude system processes and ps command itself
    local ps_printf='{printf "%-8s %-6.1f %-6.1f %-s %s\n", $2, $3, $4, $11, "N/A"}'
    # Format: PID, CPU%, MEM%, COMMAND, PORT (N/A for regular processes)
    local ps_awk_cmd="$ps_filter $ps_printf"
    
    local lsof_awk_cmd='NR>1 {printf "%-8s %-6s %-6s %-s %s\n", $2, "N/A", "N/A", $1, $9}'
    local fzf_header="Select process(es) to kill [Usage: kport or kport [port]]"
    
    # Unified function to get process list
    _get_process_list() {
        {
            printf "$header_format" "PID" "CPU%" "MEM%" "COMMAND" "PORT";
            # Regular processes
            ps aux | awk "$ps_awk_cmd" | sort -k2 -nr;
            # Processes listening on ports
            lsof -iTCP -sTCP:LISTEN -n -P 2>/dev/null | awk "$lsof_awk_cmd" | sort -k5;
        }
    }
    
    # Unified function to kill processes
    _kill_processes() {
        local target_pids="$1"
        local description="$2"
        
        if [[ -n "$target_pids" ]]; then
            echo "$description"
            if echo "$target_pids" | xargs kill -"$signal" 2>/dev/null; then
                echo "Successfully killed process(es)"
            else
                echo "Error: Failed to kill some processes. Try with signal 9." >&2
                return 1
            fi
        fi
    }
    
    # Parse arguments: if first arg is a port number, kill processes on that port
    if [[ -n "$1" && "$1" =~ ^[0-9]+$ ]]; then
        # Filter process list for specific port
        port_info=$(_get_process_list | grep -i ":$1$")
        if [[ -z "$port_info" ]]; then
            echo "No processes found listening on port $1"
            return 1
        fi
        
        # Extract PIDs and kill
        pids=$(echo "$port_info" | awk '{print $1}')
        _kill_processes "$pids" "Processes listening on port $1:"
        return
    fi
    
    # Interactive mode
    pids=$(_get_process_list | fzf -m --header="$fzf_header" --header-lines=1 | awk '{print $1}')
    _kill_processes "$pids" "Selected PIDs: $pids"
}


fcode() # FZF directory selector for VSCode with visual separation
{
    local sass_projects_dir="$HOME/dev/sass-projects"
    local packages_dir="$HOME/dev/packages"
    
    # Build directory list with headers
    local dirs=$({
        echo "=== SASS PROJECTS ==="
        [[ -d "$sass_projects_dir" ]] && find "$sass_projects_dir" -maxdepth 1 -type d ! -path "$sass_projects_dir" | sed 's|.*/||' | sort
        echo ""
        echo "=== PACKAGES ==="
        [[ -d "$packages_dir" ]] && find "$packages_dir" -maxdepth 1 -type d ! -path "$packages_dir" | sed 's|.*/||' | sort
    })
    
    local selected=$(echo "$dirs" | fzf \
        --height 50% \
        --reverse \
        --prompt="Select directory to open in VSCode > " \
        --header="Use ↑/↓ to navigate, Enter to open, Esc to cancel" \
        --preview="bash -c '
            dir=\"{}\"
            if [[ \"\$dir\" == \"=== SASS PROJECTS ===\" || \"\$dir\" == \"=== PACKAGES ===\" ]]; then
                echo \"\"
            elif [[ -d \"$sass_projects_dir/\$dir\" ]]; then
                readme_file=\$(find \"$sass_projects_dir/\$dir\" -maxdepth 1 -iname \"readme*\" -type f | head -n 1)
                [[ -n \"\$readme_file\" ]] && head -n 50 \"\$readme_file\" | fold -w 80 -s || echo \"No README found\"
            elif [[ -d \"$packages_dir/\$dir\" ]]; then
                readme_file=\$(find \"$packages_dir/\$dir\" -maxdepth 1 -iname \"readme*\" -type f | head -n 1)
                [[ -n \"\$readme_file\" ]] && head -n 50 \"\$readme_file\" | fold -w 80 -s || echo \"No README found\"
            fi
        '")
    
    # Skip headers and open selected directory
    if [[ -n "$selected" && "$selected" != "=== "* ]]; then
        if [[ -d "$sass_projects_dir/$selected" ]]; then
            code "$sass_projects_dir/$selected"
        elif [[ -d "$packages_dir/$selected" ]]; then
            code "$packages_dir/$selected"
        fi
    fi
}


lac() # Symlink AGENTS.md or CLAUDE.md
{
  local a="AGENTS.md"
  local c="CLAUDE.md"

  if [ -e "$a" ] && [ -e "$c" ]; then
    echo "Error: both $a and $c exist. Refusing to overwrite."
    return 1
  fi

  if [ ! -e "$a" ] && [ ! -e "$c" ]; then
    echo "Error: neither $a nor $c exists. Nothing to link."
    return 1
  fi

  if [ -e "$a" ]; then
    ln -s "$a" "$c"
    echo "Created symlink: $c → $a"
  else
    ln -s "$c" "$a"
    echo "Created symlink: $a → $c"
  fi
}
