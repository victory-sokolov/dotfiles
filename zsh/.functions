function calc() # Simple calculator
{
	local result="";
	result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')";
	#                       └─ default (when `--mathlib` is used) is 20
	#
	if [[ "$result" == *.* ]]; then
		# improve the output for decimal numbers
		printf "$result" |
		sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
		    -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
		    -e 's/0*$//;s/\.$//';  # remove trailing zeros
	else
		printf "$result";
	fi;
	printf "\n";
}

function mk() # Create a new directory and enter it
{
  mkdir -p "$@" && cd "$@"
}

function man() {  # Shows pretty `man` page.
  env \
    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\e[1;31m") \
    LESS_TERMCAP_me=$(printf "\e[0m") \
    LESS_TERMCAP_se=$(printf "\e[0m") \
    LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
    LESS_TERMCAP_ue=$(printf "\e[0m") \
    LESS_TERMCAP_us=$(printf "\e[1;32m") \
      man "$@"
}


function targz() # Create a new directory and enter it
{
	local tmpFile="${@%/}.tar";
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
	);

	local cmd="";
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli";
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz";
		else
			cmd="gzip";
		fi;
	fi;

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
	"${cmd}" -v "${tmpFile}" || return 1;
	[ -f "${tmpFile}" ] && rm "${tmpFile}";

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
	);

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

function fs() # Create a new directory and enter it
{
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* ./*;
	fi;
}

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ ! $(uname -s) = 'Darwin' ]; then
	if grep -q Microsoft /proc/version; then
		# Ubuntu on Windows using the Linux subsystem
		alias open='explorer.exe';
	else
		alias open='xdg-open';
	fi
fi

function cheat() # Create a new directory and enter it
{
  curl cheat.sh/${@:-cheat}
  # curl cheat.sh/$@
}

function cview() # Create a new directory and enter it
{
	csvtool readable "$1" | view -
}


# from alex sexton   gist.github.com/SlexAxton/4989674
function gifify() # Create a new directory and enter it
{
  if [[ -n "$1" ]]; then
	if [[ $2 == '--good' ]]; then
	  ffmpeg -i "$1" -r 10 -vcodec png out-static-%05d.png
	  time convert -verbose +dither -layers Optimize -resize 900x900\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > "$1.gif"
	  rm out-static*.png
	else
	  ffmpeg -i "$1" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$1.gif"
	fi
  else
	echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

function gacp() # Git: add all, commit and push. [-m "comment"]
{
	git add .
	git commit "$@"
	git push
}

function ggs() # push & commit with message `update`
{
	git add -A
    git commit -m 'update'
    git push
}

function clean_comments # remove comments (#, //) and empty lines
{
	sed -i.tmp "/^s*[#;//]/d;/^$/d" $1
}

function ssh-key() { # generate ssh key with specific name
    name="$@"
    ssh-keygen -f ~/.ssh/$name -q -N ""
    eval "$(ssh-agent -s)"
    ssh-add ~/.ssh/$name
    xclip -selection clipboard < ~/.ssh/$name.pub
    echo "public key copied to clipboard"
}

# Docker

function docker-clean() # stops and cleans all docker containers & images
{
  docker container stop $(docker container ls -aq) &&
  docker container rm $(docker container ls -aq) -f &&
  docker rmi $(docker images -a -q) -f
}

function dms() # docker-machine start
{
    machine_name="$@"
    docker-machine start $machine_name
    docker-machine env $machine_name
    eval "$(docker-machine env $machine_name)"
}


# Python

function pyenv() # create python virtual environment
{
    if [ ! -d "pyenv" ]; then
        mkdir ~/pyenv
    fi

    cd ~/pyenv
    python3 -m venv "$1"
    source "$1"/bin/activate
}


# ReactNative

function bapk() # build android apk (Must run inside react-native project)
{

    apk_path="./android/app/build/outputs/apk/debug"

	if [ ! -f package.json ]; then
		echo "package.json was not found. Run command inside root dir of your project."
		return 1
	fi

	if ! grep --quiet '"react-native":' package.json; then
		echo "Not a react-native project"
		return 1
	fi

	if [[ -d "./android/app/src/main" && ! -d "android/app/src/main/assets" ]]; then
		mkdir android/app/src/main/assets
	fi

	react-native bundle --platform android --dev false \
	                    --entry-file index.js \
	                    --bundle-output android/app/src/main/assets/index.android.bundle \
	                    --assets-dest android/app/build/intermediates/res/merged/release/ \
	                    && rm -rf android/app/src/main/res/drawable-* \
	                    && rm -rf android/app/src/main/res/raw/* \
	                    && cd android && ./gradlew assembleRelease && cd ..

	# open folder where apk file is stored
    xdg-open ${apk_path}
}


function rna() # clean cache & run react-native android simulator
{
    cd android && ./gradlew clean
    cd .. && react-native run-android
}
